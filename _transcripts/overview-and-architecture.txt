The project, named Crystal, is designed to transform client outreach for freelancers, agency owners, and business owners. Instead of sending mass cold messages, Crystal enables users to create and send personalized videos to prospects, which are available instantly after recording. This project teaches how to save and stream videos in real-time by building every component from the ground up without relying on third-party libraries. (0:42)

A significant challenge in outreach is the inability to know if a prospect has engaged with the resources sent. Crystal solves this by sending a notification to the user the moment a viewer clicks on an Crystal video. This allows for timely follow-ups to close more deals. This strategy was successfully implemented in a student's business, taking it from $0 to $115,000 in under two weeks. The application can be considered a "Loom clone" but with added AI functionalities. (1:31)

Crystal incorporates AI features for users on a paid tier. This "Crystal AI" can generate titles, descriptions, a summary, and a full transcript from the video content. This transcript can be creatively repurposed for other marketing efforts, such as an email campaign using tools like ChatGPT. The application's versatility, which allows for uses as simple as sending a birthday wish in seconds, makes it highly valuable. This value justifies a potential price point of $500 per month, far exceeding a typical 97-100 monthly fee. (2:09)

The project will be built using a comprehensive stack of modern technologies. This includes Bun or npm for package management, AWS and S3 buckets for storage, and a user interface built with Shadcn, NextUI, and Tailwind CSS. The backend and database will be managed by Neon, the latest stable version of Next.js, and Prisma. Other key tools include Nodemailer for emails, Stripe for payments, Zod and React Hook Forms for form validation, Redux for state management, and Clerk for authentication. (3:39)

For the native desktop application, the stack includes TypeScript, React Query for server-side state and caching, Electron.js, Vite.js, and vanilla React for both Windows and Mac OS. This application will allow users to connect their camera, microphone, and screen. Real-time video uploading will be handled by Socket.IO and an Express backend. Furthermore, the project will integrate Whisper AI for video transcriptions, OpenAI for generating titles and descriptions, a CMS feature from Wix Studio, and Voiceflow for an advanced AI agent that can provide AI-powered support based on video context. (4:09)

Crystal offers two pricing tiers: a Free Tier and a Pro Plan, which dictates the features available to the user. Free tier members are limited to 25 video uploads per month, with each video capped at 5 minutes in length and recorded in 720p resolution. Every member receives a personal workspace, but free users cannot invite other members to it. A unique aspect of the pricing model is that free-tier members have the ability to try out the AI features before committing to a paid plan. (4:48)

The Pro Plan, in contrast, provides users with unlimited access to all of Crystal's features. This includes the ability to record an unlimited number of videos in 1080p, with the option to switch to 720p if preferred. Users can sign into the application via Google authentication. Upon successful sign-up, they are directed to the library page, which serves as the central hub for viewing their folders and recorded videos. A key highlight of the project is that it involves building both a web application and a native desktop application. (5:39)

The application is designed with an "optimistic UI," a feature that makes it feel incredibly fast. For instance, when a user creates a new folder, it appears instantly on the client side, eliminating loading times even though the action is processed on the server. Renaming a folder is as simple as double-clicking the title, making the change, and clicking outside the text field to save it. (6:17)

The interface includes a notifications tab to view all received alerts, a billings page to manage the current plan, and a settings page. In the settings, users can switch between light and dark modes and enable "first view mode." When this mode is active, the user receives a notification as soon as a prospect views their video for the first time, which can then be accessed through the notifications page. (6:54)

The homepage functions as an onboarding guide built entirely using a CMS (Content Management System). This allows non-technical team members to access the CMS to launch marketing campaigns or share updates about new features within Crystal. The application also features a workspaces tab, which displays all public workspaces the user has been invited to, separating them from the user's dedicated personal workspace. (7:16)

Clicking on a video takes the user to the video dashboard. Here, they can view the AI-generated summary, title, and description for the video. The video is playable directly on this page. On the right side, there are several tabs. The first is "Crystal AI," where free-tier members can try the AI features before deciding to upgrade to a Pro Plan for unlimited access. (7:46)

The next tab in the video dashboard is the "transcript" tab, which displays the AI-powered video transcript. Following that is the "activity" tab, where prospects can leave comments on the video. This comment system is recursive, meaning users can reply to comments, and others can reply to those replies, creating infinite comment threads. (8:26)

If the AI-generated title and description are not satisfactory, the user can easily update this information by clicking the edit icon, making their changes, and clicking update, with the new information being saved in real-time. To upgrade to the Pro Plan, users can click the "upgrade" button, which redirects them to a Stripe-hosted page to enter their payment information for the $99 per month subscription. Once the payment is successful, they are returned to the dashboard. (8:55)

After a user upgrades to a Pro Plan, the "upgrade" button is no longer displayed. When switched to a public workspace, users gain the ability to invite others to collaborate. The invitation feature includes an optimized search function that allows users to find and add people directly to their workspace. The invited user then receives an email notification with a link to accept the invitation. If a user who is not logged into the correct account tries to accept, they will be shown a "not authorized" page. (9:35)

After signing in with the correct account, the newly invited workspace appears in the user's dashboard. The application also allows for easy organization, as users can move videos from one folder to another. One of the most powerful features is the ability to copy a direct link to a video and share it with prospects, who will see a preview version when they open the link. (10:12)

A standout feature is the embed code functionality. By clicking a button, users can generate a piece of code to paste into an email. This is particularly powerful because it displays a custom thumbnail of the video directly within the email, instantly grabbing the prospect's attention by showing them what the video is about before they even click. The AI-generated title and description are also included and can be customized. (10:46)

The tutorial also covers the Electron version of the application. The first step is to sign in using Clerk Authentication. After signing in, the application prompts the user for security access to their microphone and desktop settings. Once granted, Crystal gains access to the necessary devices and screen information. (11:22)

The desktop application is intelligent enough to remember a user's device presets. If a user has previously selected a specific camera or microphone, Crystal will remember those settings and use them by default the next time they sign in. For new users, it will select the first available device as the default. A "studio tray" provides access to recording features and a pop-up window that shows a small preview of the screen currently being recorded. This preview widget itself is not captured in the final screen recording. (11:48)

When a user starts recording, the main application window, referred to as the "studio," is automatically hidden to ensure it doesn't appear in the final video. The recording features are tied to the user's subscription plan; Pro users can record in 1080p, while free users are limited to a lower resolution. The video is saved and streamed in real-time to AWS. (12:56)

The real-time saving and streaming process involves taking buffer data from the recording, sending it via WebSockets using Socket.IO to a separate Express server application. This server processes the incoming buffer data, creates a temporary file, and then pushes that file to AWS. This entire architecture ensures that the video is being uploaded as it is being recorded. (13:24)

The Crystal desktop application functions as an overlay, allowing it to record the screen even when other applications are in full-screen mode. During a live recording demonstration, the console shows that the socket connection is active and video chunks are being sent to AWS in real-time. When the recording is stopped, the application saves everything and confirms that the video has been successfully uploaded to AWS. (13:59)

Upon returning to the web dashboard after a recording, the new screen recording is immediately available. Clicking on it reveals that an AI-generated title and description have already been created. Furthermore, the complete transcript of the video is instantly available, and the video itself is ready to be played back. (14:50)


-----


This section of the tutorial is dedicated to explaining the entire architecture of the Crystal application, emphasizing its importance for understanding the project. The core of the application consists of several key building blocks. Next.js is used for the front-end and to host API endpoints for data storage and retrieval. This is connected to a central database (DB). User authentication is managed by Clerk. A crucial component is Electron.js, a framework that enables the creation of a native desktop application using web technologies like React and JavaScript, which is necessary to access the user's operating system for full-screen recording. (15:21)

Beyond the main components, there are critical dependencies. Since real-time video data is being saved as the user records, a solution leveraging sockets is required. As Next.js does not natively support this, a separate Express server is created specifically to listen for incoming data from the Electron application via sockets. For file storage, the application uses AWS, specifically its S3 (Simple Storage Service) buckets, to store, retrieve, and manage video files. The final piece is CloudFront, an AWS service that acts as a middleman to stream videos from the private S3 bucket to the front-end application. (17:01)

The user authentication process involves two key actions upon login. First, user information is sent to Clerk to authenticate the user. Second, a user profile is created within Crystal's own database. Clerk provides essential data like a unique Clerk ID, avatar image, name, and email. This information is received by a callback URL endpoint in the Next.js application, which then uses it to create a new user entry in the database, confirming the success of the process. (19:00)

Authentication must also be handled in the native Electron.js application. The process for sign-in and sign-up in the native app also uses Clerk, which provides the user's profile information and, most importantly, their Clerk ID. This Clerk ID is then used by the Electron app to make a request to the Next.js backend. The backend queries the database for the user's profile and associated settings (like preferred microphone and camera), and sends this data back to the Electron app, ensuring all user information is synchronized. (19:55)

For a new user who has not yet configured their settings, the Electron application is designed to provide a smooth initial experience. The application accesses the user's native hardware to get a list of all available screens and microphones. It then compiles this information into an array and automatically sets the first device in each list as the default. This allows the user to start recording immediately, with the option to easily switch between different cameras or microphones later. (21:22)

Before any recording data can be streamed, a secure connection must be established between the Electron application and the Express server. After the user signs in, the Electron app sends an API key to the Express server. The server receives this key and sends a response back to confirm that the socket connection has been successfully established. Only after this handshake is complete can the application begin sending video chunks and other data to the server. (22:31)

The structure of the Electron application is fundamentally different from a standard web application. In a browser-based React app, components like a control panel or a camera preview are simply different div elements within a single window. In Electron, each of these elements is rendered as an individual, separate window. This means the control panel, the system tray icon, and the camera preview each function as their own independent React application. The main Electron file is responsible for creating and managing these multiple windows when the application starts. (23:58)

Because the Electron application consists of multiple, isolated windows, a mechanism is needed to share information and state between them. This is achieved through IPC, which stands for Inter-Process Communication. The main file sets up IPC events, which act like listeners and emitters. For example, if a user logs in through one window, an IPC event is fired to inform all other windows of the new authentication state, ensuring they all sync up with the incoming data. The IPC renderer is the API that provides access to these events. (26:31)

A specific component within the Electron app, called the "media resource," is tasked with managing the user's screen sources. Its primary job is to get a list of all available screens on the computer. When the application loads, it checks if the user has a saved screen preference in the database. If a preference exists, the media resource selects that specific screen from the available list. If not, it defaults to using the first screen in the array, ensuring a screen is always selected. (27:51)

The core of the recording functionality is handled by two main parts: the "media stream" and the "media recorder." The media stream uses the Navigator API to perform the screen recording and provides the output as a buffer stream of data. This raw stream is then passed into the media recorder, which is an API that provides methods to control the stream. These methods include start() and stop() to begin and end the recording, and dataavailable to access the data as it's being generated. (29:03)

The dataavailable method is what makes the real-time streaming and saving possible. By using this method, a timer can be setâ€”in this application, it's set to one second. Every second, a callback function is triggered, which takes the latest chunk of the buffer stream data and sends it to the Express server via the established WebSocket connection. This process allows the video file to be constructed on the server side as the user is recording, rather than waiting until the recording is finished. (31:23)

While the real-time streaming is in progress, the Express server performs a sequence of steps to handle the incoming data. As each chunk arrives, it is appended to a buffer array. This array is then converted into a blob, from which a readable stream is created. This readable stream is then "piped" to a write stream, which continuously writes the data to a temporary file within the Express server's file system, effectively building the complete video file piece by piece. (33:24)

After the user clicks the "stop" button to end the recording, a final sequence of events is triggered on the Express server. The server first locates the now-complete temporary video file within its file system. It then makes an API call to the Next.js backend to create a placeholder entry in the database, setting a boolean property like processing to true. This ensures the user sees a "processing" state in the UI while the video is being uploaded and finalized. (35:43)

With the file ready, the upload and AI processing begins. The server uploads the video file to the AWS S3 bucket. At the same time, it initiates the AI sequence, but only if the user is on a paid tier. This process starts with Whisper AI, which generates a full transcript from the video. This transcript is then passed to OpenAI to create an appropriate title and description. Additionally, the transcript can be fed into a Voiceflow knowledge base, creating a powerful feature where users can ask questions and receive AI-powered answers based on the video's content. (37:10)

To complete the process, after the file is uploaded to AWS and the asynchronous AI tasks are running, the Express server makes a final API call to the Next.js backend. This call updates the entry in the database, changing its status from "processing" to "completed." Once this is done, the temporary video file is deleted from the Express server's local file system to free up space. This concludes the entire server-side workflow for a single recording. (40:39)

Finally, the role of CloudFront is to securely deliver the stored videos to the user. Since the S3 bucket is configured to be private, the Next.js front-end application cannot directly access its contents. CloudFront is an AWS service that is granted special permissions to access the private S3 bucket. When a user wants to watch a video, the Next.js application makes a request to CloudFront, which then fetches the specific video file from S3 and streams it securely to the user's browser. (42:43)